var express = require('express');
var app = express();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res){
    res.sendFile(__dirname + '/public/snatch_files/snatch.html');
});





app.use(express.static('public'));

var qty_tiles = 100;
var snatchSvr_factory = require('./snatch-server.js');

var SNATCH_GAMES = [];//a dictionary for game objects...

var SDC_factory = require('./scrape_definition_client.js');
var my_SDC = SDC_factory();
    
var prev_result = undefined;
var prev_word = undefined;
my_SDC.rEvent.on('searchComplete', function(result){
    prev_result = result;

});

app.get('/definition/*', function(req, res){
    var frags = req.url.split('/');
    var word = frags[frags.length-1];
    my_SDC.lookup_definition(word);
    res.send('You have just looked up: ' + word + '. <br> Previously, you\
 looked up ' + prev_word + ' and a search result was:<br>' + prev_result);
    prev_word = word;
});

///This is an incomplete fragment...
app.get('/join/*', function(req, res){
    var frags = req.url.split('/');
    var tag = frags[frags.length-1];
});

//a hash table...
//note how it is global for all connection...
var ActiveRoomsList = {};

io.on('connection', function(socket){

    //basic logging
    console.log('a user connected, with ID: '+socket.id);

    socket.on('disconnect', function(){

	if(socket.ROOM){
	    var myGame = SNATCH_GAMES[socket.ROOM];
	}
	if(myGame){
	    var dis_pl_i = myGame.playerIndexFromSocket(socket.id);
	}

	// only if (1) the socket is assigned a .ROOM property (2) a game exist there (should always be true...)
	// (3) the client at the socket actually entered the game and became a player.
	if(dis_pl_i !== undefined){
	    var dis_pl_i = myGame.playerIndexFromSocket(socket.id);
	    socket.broadcast.to(socket.ROOM).emit('player disconnected',dis_pl_i);
	    var dis_pl_name = myGame.getPlayerObject(socket.id).name;
	    myGame.removePlayer(socket.id);
	    console.log('Player ' + dis_pl_i + ' (' + dis_pl_name + ') disconnected (socket.id = ' + socket.id + ')');
	}else{
	    console.log('Connection closed (socket.id = ' + socket.id + ') - no player associated...');
	}
    });

    socket.on('request to init room', function (data){

	//create a new room tag (no one added to room yet)

	var code = randomIndex = Math.floor(Math.random() * 1000);//from 0 to 999
	var c1 = randomIndex = Math.floor(Math.random() * 5);//from 0 to 4

	function pad(num, size) {
	    var s = "000000000" + num;
	    return s.substr(s.length-size);
	}
	var pcode = pad(code,3);

	var v_words = ["purple","orange","green","golden","black"];
	var my_tag = v_words[c1] + " " + pcode; 

	ActiveRoomsList[my_tag] = "initiated";
	console.log("randomly generated new room tag: [" + my_tag + "]");
    	socket.emit('your room tag', my_tag);
    });

    socket.on('request rooms list', function (no_data){
	//prepare list of rooms for sending...
	console.log("Rooms list sent to an anonymouse client...");
    	socket.emit('rooms list', ActiveRoomsList);
    });


    socket.on('join room and start', function (room_req){
	//respond by providing a set of colours to choose between
	console.log("'join room and start' message recieved. Room = " + room_req);

	if(ActiveRoomsList[room_req] == "initiated"){//check that this is a valid room
	    
	    //create a new game...
	    SNATCH_GAMES[room_req] = snatchSvr_factory(qty_tiles);
	    ActiveRoomsList[room_req] = "exists";

	}

	if(ActiveRoomsList[room_req] == "exists"){
	    
	    //first add the socket to the room.
	    // this is not special socket io function, just adding a custom property into the object.
	    socket.ROOM = room_req;

	    //this causes the socket to be subscribed to room-specific broadcasts...
	    socket.join(room_req);

	    var myGame = SNATCH_GAMES[socket.ROOM];
	    var gameObj = myGame.getGameObject();
	    var colorChoices = myGame.provideColorChoice(socket.id)
	    var msg_obj = {color_choice: colorChoices,
			   players_t: gameObj.playerSet	    
			  };

	    //this data structure needs to be generated by the myGame object...
	    socket.emit('player color choices', msg_obj);

	}else{
	    console.log("somehow, the client requested an non-existant room");
	}

    });



    //client provides player details, which is also a request for the full game state
    socket.on('player joined with details', function (details_obj){
	//this newly joined player can be added to the game...
	console.log('player joined with details : ' + JSON.stringify(details_obj));
	var myGame = SNATCH_GAMES[socket.ROOM];
	myGame.addPlayer(details_obj, socket.id);

	//index to the new joiner
	var pl_i = myGame.playerIndexFromSocket(socket.id);
	socket.emit('give client their player index', pl_i);

	//gamestate to the new joiner
	var gameObj = myGame.getGameObject();
	socket.emit('full game state transmission', gameObj);//now just transmit to the new player
	
	//new joiner to the rest of the players
	var rPID = details_obj.reclaiming_player_index;
	if(rPID !== undefined){
	    var player_join_details = {rejoin_PID: rPID};
	}else{
	    var player_join_details = {player_object: myGame.getPlayerObject(socket.id), rejoin_PID: undefined};
	}
	socket.broadcast.to(socket.ROOM).emit('player has joined game', player_join_details);
    });

    socket.on('reset request', function (blank_msg){
	var myGame = SNATCH_GAMES[socket.ROOM];
	var all_one_agree = myGame.playerAgreesToReset(socket.id);//the return value indicates whether all players agree to the reset
	if (all_one_agree){
	    myGame.resetGame(qty_tiles);
	    //now sent out the new game object:
	    var gameObj = myGame.getGameObject();
	    io.to(socket.ROOM).emit('full game state transmission', gameObj);
	}
	else{//in the case where there are other players...
	    var pl_i = myGame.playerIndexFromSocket(socket.id);
	    socket.broadcast.to(socket.ROOM).emit('player wants reset', pl_i);
	}
    });



    //client requests to turn over a tile
    socket.on('agree to reset', function(agrees){
	var myGame = SNATCH_GAMES[socket.ROOM];
	var pl_i = myGame.playerIndexFromSocket(socket.id);
	socket.broadcast.to(socket.ROOM).emit('player response to reset request', {player_index: pl_i, response: agrees});
	if(agrees){
	    var reset_agreement = myGame.playerAgreesToReset(socket.id);//the return value indicates whether all players agree to the reset
	    if (reset_agreement){
		myGame.resetGame(qty_tiles);
		//now sent out the new game object:
		var gameObj = myGame.getGameObject();
		io.to(socket.ROOM).emit('full game state transmission', gameObj);
	    }
	}
    });



    socket.on('player submits word', function(tile_id_array){
	console.log("["+socket.ROOM+"]: Snatch submission with letters: ",tile_id_array);
	var myGame = SNATCH_GAMES[socket.ROOM];
	var SnatchResponse = myGame.playerSnatches(tile_id_array, socket.id)


	if(SnatchResponse.val_check == 'accepted'){
	    io.to(socket.ROOM).emit('snatch assert', SnatchResponse.SnatchUpdateMsg);	    
	}else{
	    socket.emit('snatch rejected', SnatchResponse.val_check);
	}
    });




    //client requests to turn over a tile
    socket.on('tile turn request', function(blank_msg){
	var myGame = SNATCH_GAMES[socket.ROOM];
	var newTile_info = myGame.flipNextTile(socket.id);
	io.to(socket.ROOM).emit('new turned tile', newTile_info);
	if(newTile_info){
	    console.log("["+socket.ROOM+"]: PI=" + newTile_info.flipping_player + " flips tileID=" + newTile_info.tile_index + " (" + newTile_info.tile_letter + ")");
	}else{
	    console.log("All tiles turned - flip message recieved...");
	}
    });


    //client requests to turn over a tile
    socket.on('many_tile_turn_hack', function(n_tiles){

	var myGame = SNATCH_GAMES[socket.ROOM];

	var letters = [];
	var tileID_first = undefined;
	var tileID_final = undefined;
	var fl_player = undefined;
	var period = 100;

	var R1 = function(i){
	    var newTile_info = myGame.flipNextTile(socket.id);
	    if(newTile_info){
		io.to(socket.ROOM).emit('new turned tile', newTile_info);
		letters.push(newTile_info.tile_letter);
		tileID_final = newTile_info.tile_index
		fl_player = newTile_info.flipping_player;
		if(i==0){tileID_first = newTile_info.tile_index;}
		if(i < n_tiles){setTimeout(function(){R1(i+1);},period);}//here is the recursive call achieving simple looping...
	    }
	    if(i >= n_tiles){
		if(tileID_final !== undefined){
		    console.log("PI=" + fl_player + " has turned multiple tiles at once, from\
tileID=" + tileID_first + " to tileID=" + tileID_final + ". The letters are: " + letters);
		}else{
		    console.log("All tiles turned");
		}

	    }
	};
	R1(0);

    });


});

http.listen(3008,'127.0.0.1');
console.log('Snatch server, listening on 127.0.0.1:3008');
